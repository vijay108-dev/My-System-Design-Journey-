#  High-Level Design (HLD) vs âš™ï¸ Low-Level Design (LLD)

---

##  **HLD (High-Level Design)**

### **Meaning**
It shows how the entire system works from the top view â€” like a blueprint or architecture of the project.

### **Focus**
- Major components or modules  
- How those modules talk to each other  
- What technologies or databases will be used  
- Big picture â€” not code-level details

### **Example**
Suppose you are designing a food delivery app like **Swiggy**.

**HLD would include:**
- User Service  
- Restaurant Service  
- Order Service  
- Delivery Service  
- Database choices (SQL/NoSQL)  
- APIs between these services  
- Load balancer, caching, etc.

>  Itâ€™s like a **map of the city**, showing how places are connected â€” not the small details inside each building.

---

##  **LLD (Low-Level Design)**

### **Meaning**
It shows how each module will actually work internally â€” close to the coding part.

### **Focus**
- Classes, methods, and attributes  
- Relationships between classes (inheritance, composition, etc.)  
- Function flow and logic  
- Database schema or tables in detail

### **Example (for same Swiggy app)**
For the **Order Service**, LLD would include:
- Class `Order` with attributes: `orderId`, `userId`, `restaurantId`, `items`, `status`  
- Methods like `placeOrder()`, `cancelOrder()`, `updateStatus()`  
- How order details are stored in the database

>  Itâ€™s like the **blueprint of a single building**, showing where each wall, door, and window goes.

---

##  **Summary**

| Aspect | HLD | LLD |
|--------|-----|-----|
| **Level** | Big picture | Detailed picture |
| **Focus** | Architecture, components | Classes, methods, database schema |
| **Audience** | Architects, senior devs | Developers |
| **Example** | â€œWeâ€™ll use microservices with a MySQL DBâ€ | â€œClass Order has methods `placeOrder()` and `cancelOrder()`â€ |

---

 **In short:**  
- **HLD** = what the system looks like overall  
- **LLD** = how each part of that system is built inside

# 2. Clientâ€“Server Model

---

##  What is the Clientâ€“Server Model?

Itâ€™s a way computers **communicate** over a **network** â€” like the Internet.

In this model, there are two main parts:

- **Client:** the one who sends a **request**  
- **Server:** the one who gives a **response**

---

##  Client

The **client** is the user or device that **wants something**.

- It could be your **web browser (like Chrome)** or a **mobile app**.  
- The client **asks** the server for data or services.

 **Example:**  
When you open **www.google.com** in your browser â€”  
your browser (client) sends a **request** to Googleâ€™s server.

---

## ğŸ–¥ï¸ Server

The **server** is a powerful computer that **listens** to client requests and **sends back responses**.

- It stores data, files, or runs backend logic.  
- It is always **on** and ready to handle multiple requests.

 **Example:**  
Googleâ€™s server receives your request, processes it, and **sends the search results** back to your browser.

---

##  How it Works (Step by Step)

1. **Client sends a request**  
   â†’ â€œHey server, I want this web page or data.â€  
2. **Server receives and processes the request**  
   â†’ Finds the right information or runs some code.  
3. **Server sends a response back**  
   â†’ â€œHereâ€™s the data you asked for.â€  
4. **Client displays the response**  
   â†’ Browser shows the webpage or app updates the screen.

---

##  Example: Visiting a Website

1. You type **www.swiggy.com** in your browser.  
2. The browser (**client**) sends a request to **Swiggyâ€™s web server**.  
3. The server looks up **restaurant data** in its database.  
4. The server sends back **HTML, CSS, and data**.  
5. The browser shows the **webpage** to you.

---

 **In short:**  
> The **client asks**, the **server serves**.  
This model is the **foundation of how the Internet works**.



#  Scaling â€” What It Means

When an application grows â€” more users, more traffic, more data â€”  
you need to increase your systemâ€™s capacity (make it handle more load).

That process is called **scaling**.  
And there are two main ways to do it:  
ğŸ‘‰ **Vertical Scaling** and **Horizontal Scaling**

---

##  1. Vertical Scaling (Scale Up)

### **Meaning**
You make **one machine more powerful**.

That means:
- Add more **CPU**, **RAM**, or **storage** to the same server.  
- You are improving the **existing serverâ€™s capacity**.

### **Example**
You have one server handling 1,000 users.  
To handle 2,000 users, you:
- Upgrade from **8 GB RAM â†’ 32 GB RAM**  
- Upgrade from **4 cores â†’ 16 cores**

Now the same server can handle more traffic.

### **Advantages**
âœ… Simple to implement  
âœ… No need to change application logic  

### **Disadvantages**
âŒ Thereâ€™s a **hardware limit** â€” you canâ€™t keep upgrading forever  
âŒ If the server fails, everything goes down (**single point of failure**)  

---

##  2. Horizontal Scaling (Scale Out)

### **Meaning**
You **add more servers or machines** to share the load.

That means:
- Instead of one big machine, you use **many smaller machines** working together.  
- A **load balancer** distributes requests among them.

### **Example**
You have one server handling 1,000 users.  
To handle 10,000 users, you:
- Add **9 more servers**  
- Use a **load balancer** to divide traffic among all 10 servers.

### **Advantages**
âœ… Practically **no limit** â€” you can keep adding machines  
âœ… More **reliable** â€” if one server fails, others keep working  

### **Disadvantages**
âŒ **Harder to manage**  
âŒ Requires **distributed system design** (session management, databases, etc.)  


 **In short:**  
- **Vertical Scaling â†’** Make one server stronger  
- **Horizontal Scaling â†’** Add more servers to share the work


